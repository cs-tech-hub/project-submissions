name: Auto Fork + Install Sync

on:
  issues:
    types: [opened]

permissions:
  issues: write
  contents: write
  metadata: read

env:
  ORG: "student-projects-org"   # <-- REPLACE with your Org name
  SYNC_CRON: "*/10 * * * *"     # every 10 minutes

jobs:
  auto_fork_and_setup_sync:
    runs-on: ubuntu-latest
    steps:
      - name: Parse repo URL from issue body
        id: parse
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = context.payload.issue.body || "";
            const match = body.match(/https?:\/\/github\.com\/[^\/\s]+\/[^\/\s]+/i);
            return match ? match[0] : "";

      - name: Fail and comment if no URL found
        if: ${{ steps.parse.outputs.result == '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: "❌ No valid GitHub repo URL found. Please paste a repo URL like `https://github.com/username/repo`."
            });
            throw new Error("No repo URL provided in issue body");

      - name: Fork into org (if needed) and install sync workflow
        uses: actions/github-script@v7
        env:
          ORG: ${{ env.ORG }}
          SYNC_CRON: ${{ env.SYNC_CRON }}
          REPO_URL: ${{ steps.parse.outputs.result }}
        with:
          github-token: ${{ secrets.ORG_TOKEN }}
          script: |
            const repoUrl = process.env.REPO_URL;
            const org = process.env.ORG;
            const syncCron = process.env.SYNC_CRON;

            // parse https://github.com/owner/repo
            const m = repoUrl.match(/^https?:\/\/github\.com\/([^\/]+)\/([^\/\s#?\.]+)(?:\.git)?/i);
            if (!m) throw new Error("Couldn't parse repo URL");
            const srcOwner = m[1];
            const srcRepo = m[2];

            // find default branch (fallback to main)
            let defaultBranch = 'main';
            try {
              const r = await github.rest.repos.get({ owner: srcOwner, repo: srcRepo });
              defaultBranch = r.data.default_branch || defaultBranch;
            } catch (e) {
              // ignore and keep default 'main'
            }

            // check if org already has a repo with same name
            let forkExists = true;
            try {
              await github.rest.repos.get({ owner: org, repo: srcRepo });
            } catch (e) {
              if (e.status === 404) forkExists = false;
              else throw e;
            }

            if (!forkExists) {
              // create fork into org
              await github.request('POST /repos/{owner}/{repo}/forks', {
                owner: srcOwner,
                repo: srcRepo,
                organization: org
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number,
                body: `✅ Fork requested: ${srcOwner}/${srcRepo} → ${org}/${srcRepo}. Setting up auto-sync...`
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number,
                body: `ℹ️ ${org}/${srcRepo} already exists. Ensuring sync workflow is present...`
              });
            }

            // wait for fork to be available (small loop)
            let tries = 0;
            while (tries < 30) {
              try {
                await github.rest.repos.get({ owner: org, repo: srcRepo });
                break;
              } catch (e) {
                if (e.status === 404) {
                  await new Promise(r => setTimeout(r, 3000));
                  tries++;
                } else throw e;
              }
            }

            // prepare sync workflow content
            const path = '.github/workflows/sync.yml';
            const syncContent = `name: Sync Fork
on:
  schedule:
    - cron: '${syncCron}'
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: repo-sync/github-sync@v2
        with:
          source_repo: ${srcOwner}/${srcRepo}
          source_branch: ${defaultBranch}
          destination_branch: ${defaultBranch}
          github_token: \${{ secrets.GITHUB_TOKEN }}
`;

            const contentB64 = Buffer.from(syncContent, 'utf8').toString('base64');

            // get existing file sha if present
            let sha;
            try {
              const { data } = await github.rest.repos.getContent({ owner: org, repo: srcRepo, path });
              if (!Array.isArray(data)) sha = data.sha;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            await github.rest.repos.createOrUpdateFileContents({
              owner: org,
              repo: srcRepo,
              path,
              message: sha ? "chore: update sync workflow" : "chore: add sync workflow",
              content: contentB64,
              sha
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number,
              body: `🎉 All set! Your project is now at https://github.com/${org}/${srcRepo}\n\nIt will auto-sync from ${srcOwner}/${srcRepo} every 10 minutes.`
            });
